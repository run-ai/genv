#!/usr/bin/env python3

import argparse
import asyncio
from collections import defaultdict
import itertools
import os
import shutil
import sys
from typing import Dict, Iterable, NoReturn, Optional

import genv

QUERIES = {
    "host": lambda host, env: host,
    "eid": lambda host, env: env["eid"],
    "creation": lambda host, env: env["creation"],
}


async def query_devices(hosts: Iterable[str], root: str) -> Dict[str, Dict]:
    """
    Query devices on multiple hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory

    :return: A mapping from host to its devices information
    """
    stdouts = await genv.remote.run(
        hosts,
        root,
        "exec",
        "devices",
        "ps",
        "--format csv",
        "--no-header",
        "--timestamp",
    )

    def parse_stdout(stdout: str) -> Dict[int, Iterable[Dict]]:
        attachments = dict()

        for line in stdout.splitlines():
            idx, eid, env_name, attached = line.split(",")

            if idx not in attachments:
                attachments[idx] = list()

            if not eid:
                continue

            attachments[idx].append(
                dict(
                    eid=eid,
                    env_name=env_name,
                    attached=attached,
                )
            )

        return attachments

    return {host: parse_stdout(stdout) for host, stdout in zip(hosts, stdouts)}


async def query_envs(hosts: Iterable[str], root: str) -> Dict[str, Dict]:
    """
    Query environments on multiple hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory

    :return: A mapping from host to its active environments
    """
    stdouts = await genv.remote.run(
        hosts,
        root,
        "exec",
        "envs",
        "ps",
        "--format csv",
        "--no-header",
        "--timestamp",
    )

    envs = defaultdict(list)

    for host, stdout in zip(hosts, stdouts):
        for line in stdout.splitlines():
            eid, user, name, creation, pids = line.split(",")

            envs[host].append(
                dict(
                    eid=eid,
                    user=user,
                    name=name,
                    creation=creation,
                    pids=[int(pid) for pid in pids.split(" ")],
                )
            )

    return dict(envs)


async def find_available_host(
    hosts: Iterable[str], root: str, gpus: Optional[int]
) -> str:
    """
    Finds a host with enough available resources.

    Raises 'RuntimeError' if cannot find such host.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory
    :param gpus: Device count specification

    :return: Hostname with enough available resources
    """
    host_to_devices = await query_devices(hosts, root)

    for host, devices in host_to_devices.items():
        available = len(
            [idx for idx, attachments in devices.items() if len(attachments) == 0]
        )

        if gpus is not None:
            if available < gpus:
                continue

        return host

    raise RuntimeError("Cannot find a host with enough available resources")


def enforce_non_env_processes(
    hosts: Iterable[str],
    snapshots: Iterable[genv.Snapshot],
    surveys: Iterable[genv.enforce.Survey],
) -> None:
    for host, snapshot, survey in zip(hosts, snapshots, surveys):
        for process in snapshot.processes:
            if process.eid is not None:
                continue

            print(
                f"Process {process.pid} on host {host} is not running in a GPU environment"
            )

            survey.terminate(process)


def enforce_max_devices_for_user(
    username: str,
    snapshots: Iterable[genv.Snapshot],
    surveys: Iterable[genv.enforce.Survey],
    maximum: int,
) -> None:
    attached = sum(len(snapshot.attached()) for snapshot in snapshots)

    if attached <= maximum:
        return

    over = attached - maximum

    hosts = len([snapshot for snapshot in snapshots if len(snapshot.envs) > 0])

    print(
        f"User {username} is using {attached} devices on {hosts} hosts which is {over} more than the maximum allowed"
    )

    detached = 0

    for snapshot, survey in zip(snapshots, surveys):
        for device in snapshot.attached():
            if detached == over:
                break  # already detached enough devices

            survey.detach(
                [env for env in snapshot.envs.filter(eids=device.eids)], device.index
            )

            detached += 1


def enforce_max_devices_per_user(
    hosts: Iterable[str],
    snapshots: Iterable[genv.Snapshot],
    surveys: Iterable[genv.enforce.Survey],
    maximum: int,
) -> None:
    usernames = set(
        env.username for snapshot in snapshots for env in snapshot.envs if env.username
    )

    for username in usernames:
        enforce_max_devices_for_user(
            username,
            snapshots=[snapshot.filter(username) for snapshot in snapshots],
            surveys=surveys,
            maximum=maximum,
        )


async def do_activate(
    hosts: Iterable[str],
    root: str,
    gpus: Optional[int],
    name: Optional[str],
    prompt: bool,
) -> NoReturn:
    """
    Finds a remote host with enough available resources, connects to it using SSH
    and activates an environment inside with the given specification.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory
    :param gpus: Device count specification
    :param name: Environment name specification
    :param prompt: Change the remote shell prompt

    :return: Does not return
    """
    host = await find_available_host(hosts, root, gpus)

    env = {"GENV_PREACTIVATE": 1, "GENV_PREACTIVATE_PROMPT": "1" if prompt else "0"}

    if gpus:
        env.update({"GENV_PREACTIVATE_GPUS": gpus})

    if name:
        env.update({"GENV_PREACTIVATE_ENVIRONMENT_NAME": name})

    path = shutil.which("ssh")
    args = (
        [path]
        + list(itertools.chain(*(["-o", f"SendEnv={variable}"] for variable in env)))
        + [host]
    )
    env = dict(os.environ, **{k: str(v) for k, v in env.items()})

    os.execve(path, args, env)


async def do_devices(
    hosts: Iterable[str],
    root: str,
    format: str,
    header: bool,
    summary: bool,
) -> None:
    """
    Prints information about devices on multiple hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory
    :param format: Output format
    :param header: Print a header as part of the output
    :param summary: Print a summary as part of the output

    :return: None
    """
    host_to_devices = await query_devices(hosts, root)

    if header:
        if format == "csv":
            print("HOST,TOTAL,AVAILABLE")
        elif format == "tui":
            print("HOST                     TOTAL    AVAILABLE")

    total = 0
    available = 0

    for host, devices in host_to_devices.items():
        host_total = len(devices)
        host_available = len(
            [idx for idx, attachments in devices.items() if len(attachments) == 0]
        )

        total += host_total
        available += host_available

        if format == "csv":
            print(f"{host},{host_total},{host_available}")
        elif format == "tui":
            print(f"{host:<25}{host_total:<9}{host_available}")

    if summary:
        print(
            f"\nTotal {total} devices with {available} available on {len(hosts)} hosts"
        )


async def do_enforce(
    hosts: Iterable[str],
    root: str,
    interval: int,
    non_env_processes: bool,
    max_devices_per_user: Optional[int],
) -> None:
    """
    Enforce GPU usage on multiple hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory

    :return: None
    """
    while True:
        snapshots = await genv.remote.snapshot(hosts, root)
        surveys = [genv.enforce.Survey() for _ in hosts]

        if non_env_processes:
            enforce_non_env_processes(hosts, snapshots, surveys)

        if max_devices_per_user is not None:
            enforce_max_devices_per_user(
                hosts, snapshots, surveys, maximum=max_devices_per_user
            )

        # TODO(raz): terminate processes that run in environments but on devices that are not attached

        reports = [
            survey.report(snapshot) for snapshot, survey in zip(snapshots, surveys)
        ]

        await genv.remote.enforce.execute(hosts, root, reports)

        if interval == 0:
            break

        await asyncio.sleep(interval)


async def do_envs(
    hosts: Iterable[str],
    root: str,
    format: str,
    header: bool,
    summary: bool,
    timestamp: bool,
) -> None:
    """
    Prints information about active environments on multiple hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory
    :param format: Output format
    :param header: Print a header as part of the output
    :param summary: Print a summary as part of the output

    :return: None
    """
    host_to_envs = await query_envs(hosts, root)

    if header:
        if format == "csv":
            print("HOST,ID,USER,NAME,CREATED")
        elif format == "tui":
            print(
                "HOST                     ID      USER            NAME            CREATED"
            )

    for host, envs in host_to_envs.items():
        for env in envs:
            eid = env["eid"]
            user = env["user"]
            name = env["name"]
            created = (
                env["creation"] if timestamp else genv.utils.time_since(env["creation"])
            )

            if format == "csv":
                print(f"{host},{eid},{user},{name},{created}")
            elif format == "tui":
                print(f"{host:<25}{eid:<8}{user:<16}{name:<16}{created}")

    if summary:
        print(
            f"\nTotal {sum([len(envs) for envs in host_to_envs.values()])} environments on {len(hosts)} hosts"
        )


async def do_query(
    hosts: Iterable[str], root: str, name: str, queries: Iterable[str]
) -> None:
    """
    Query environment data using a query string and print the results to the string.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory
    :param name: Environment name
    :param queries: List of query names

    :return: None
    """
    host_to_envs = await query_envs(hosts, root)

    for host, envs in host_to_envs.items():
        for env in envs:
            if env["name"] != name:
                continue

            query = lambda name: str(QUERIES[name](host, env) or "")

            print(",".join(query(name) for name in queries))


def parse_args() -> argparse.Namespace:
    """
    Parses the arguments passed to this executable.

    :return: Argument values
    """

    def activate(parser):
        parser.add_argument("--name", help="Environment name")
        parser.add_argument("--gpus", type=int, help="Environment device count")
        parser.add_argument(
            "--no-prompt",
            dest="prompt",
            action="store_false",
            help="Don't change the shell prompt",
        )

    def devices(parser):
        parser.add_argument(
            "--no-header",
            dest="header",
            action="store_false",
            help="Do not print column headers",
        )
        parser.add_argument(
            "--no-summary",
            dest="summary",
            action="store_false",
            help="Do not print summary",
        )
        parser.add_argument(
            "--format",
            choices=["csv", "tui"],
            help="Output format; CSV or TUI (Text-based user interface)",
            default="tui",
        )

    def enforce(parser):
        parser.add_argument(
            "--interval",
            type=int,
            default=10,
            help="interval in seconds between enforcement cycles; 0 means run once (default: %(default)s)",
        )

        enforcements = parser.add_argument_group("enforcements")

        def add_enforcement(
            name: str, *, dest: str, help: str, default: bool = True
        ) -> None:
            """
            Adds a mutual exclusive group for an enforcement flag with true and false actions.
            """
            group = enforcements.add_mutually_exclusive_group()

            group.add_argument(
                f"--{name}",
                action="store_true",
                default=default,
                help=help + " (default: %(default)s)",
                dest=dest,
            )

            group.add_argument(
                f"--no-{name}",
                action="store_false",
                dest=dest,
            )

        add_enforcement(
            "non-env-processes",
            dest="non_env_processes",
            help="terminate processes that are not running in a GPU environment",
            default=False,
        )

        enforcements.add_argument(
            "--max-devices-per-user",
            type=int,
            help="maximum allowed attached devices for each user",
        )

    def envs(parser):
        parser.add_argument(
            "--no-header",
            dest="header",
            action="store_false",
            help="Do not print column headers",
        )
        parser.add_argument(
            "--no-summary",
            dest="summary",
            action="store_false",
            help="Do not print summary",
        )
        parser.add_argument(
            "--timestamp", action="store_true", help="Print a non-prettified timestamp"
        )
        parser.add_argument(
            "--format",
            choices=["csv", "tui"],
            help="Output format; CSV or TUI (Text-based user interface)",
            default="tui",
        )

    def query(parser):
        parser.add_argument("--name", required=True, help="Environment name")
        parser.add_argument(
            "--query",
            "--queries",
            dest="queries",
            nargs="+",
            choices=QUERIES.keys(),
            required=True,
        )

    parser = argparse.ArgumentParser(description="Genv remote")

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "-H",
        "-host",
        "--host",
        dest="hosts",
        help="Comma-separated hostnames or IP addresses",
    )
    group.add_argument(
        "-hostfile",
        "--hostfile",
        help="A file containing one hostname or IP address per line",
    )

    parser.add_argument(
        "--root",
        default="$HOME/genv",
        help="Genv installation root on remote hosts (default: %(default)s)",
    )

    subparsers = parser.add_subparsers(dest="command")

    for command, help in [
        (activate, "Activate environment in a remote host"),
        (devices, "Show device information from all hosts"),
        (enforce, "Enforce GPU usage on all hosts"),
        (envs, "List all active environments"),
        (query, "Query environments or a specific one"),
    ]:
        command(subparsers.add_parser(command.__name__, help=help))

    return parser.parse_args()


async def main(args: argparse.Namespace, hosts: Iterable[str]) -> None:
    """
    Parses the arguments and runs the requested command.

    :return: None
    """
    if args.command == "activate":
        await do_activate(hosts, args.root, args.gpus, args.name, args.prompt)
    elif args.command == "devices":
        await do_devices(hosts, args.root, args.format, args.header, args.summary)
    elif args.command == "enforce":
        await do_enforce(
            hosts,
            args.root,
            args.interval,
            args.non_env_processes,
            args.max_devices_per_user,
        )
    elif args.command == "envs":
        await do_envs(
            hosts, args.root, args.format, args.header, args.summary, args.timestamp
        )
    elif args.command == "query":
        await do_query(hosts, args.root, args.name, args.queries)


if __name__ == "__main__":
    args = parse_args()

    if args.hostfile:
        with open(args.hostfile, "r") as f:
            hosts = [
                line
                for line in [line.strip() for line in f.readlines()]
                if line and not line.startswith("#")
            ]
    else:
        hosts = args.hosts.split(",")

    try:
        asyncio.run(main(args, hosts))
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)
    except KeyboardInterrupt:
        if args.command != "enforce":
            raise
