#!/usr/bin/env python3

import argparse
import asyncio
from collections import defaultdict
import itertools
import json
import os
import shutil
import sys
from typing import Dict, Iterable, NoReturn, Optional, TextIO

import genv.usage
import genv.utils


def reprint(
    hosts: Iterable[str], outputs: Iterable[str], file: TextIO = sys.stdout
) -> None:
    """
    Reprints outputs from multiple hosts with the hostname as a prefix.

    :param hosts: Hostnames or IP addresses
    :param outputs: Output for every host
    :param file: Output to print to
    """
    for host, output in zip(hosts, outputs):
        for line in output.splitlines():
            print(f"[{host}] {line}", file=file)


async def start_on_host(
    host: str, root: str, stdin: int, *args: str, sudo: bool = False
) -> asyncio.subprocess.Process:
    """
    Starts a background process that runs a Genv command on a remote host over SSH.

    :param host: Hostname or IP address
    :param root: Genv installation root directory
    :param args: Genv command line to run
    :param sudo: Run command as root using sudo

    :return: Returns the SSH process
    """
    command = f'env PATH="{root}/bin:$PATH" genv {" ".join(args)}'

    if sudo:
        command = f"sudo {command}"

    return await asyncio.create_subprocess_exec(
        "ssh",
        host,
        command,
        stdin=stdin,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )


async def run_on_hosts(
    hosts: Iterable[str],
    root: str,
    *args: str,
    stdins: Optional[Iterable[str]] = None,
    sudo: bool = False,
) -> Iterable[str]:
    """
    Runs a Genv command on multiple hosts over SSH.
    Waits for the command to finish successfully on all hosts.
    Raises 'RuntimeError' if failed to connect to any of the hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory
    :param args: Genv command line to run
    :param stdins: Stdins to send
    :param sudo: Run command with sudo

    :return: Returns the stdout from all hosts
    """
    processes = [
        await start_on_host(
            host,
            root,
            asyncio.subprocess.PIPE if stdins else asyncio.subprocess.DEVNULL,
            *args,
            sudo=sudo,
        )
        for host in hosts
    ]

    outputs = await asyncio.gather(
        *(
            process.communicate(stdin.encode("utf-8") if stdin else None)
            for process, stdin in zip(processes, stdins or [None for _ in hosts])
        )
    )

    stdouts = [stdout.decode("utf-8").strip() for stdout, _ in outputs]
    stderrs = [stderr.decode("utf-8").strip() for _, stderr in outputs]

    for host, process, stderr in zip(hosts, processes, stderrs):
        if process.returncode != 0:
            raise RuntimeError(f"Failed connecting over SSH to {host} ({stderr})")

    reprint(hosts, stderrs, file=sys.stderr)

    return stdouts


async def query_devices(hosts: Iterable[str], root: str) -> Dict[str, Dict]:
    """
    Query devices on multiple hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory

    :return: A mapping from host to its devices information
    """
    stdouts = await run_on_hosts(
        hosts,
        root,
        "exec",
        "devices",
        "ps",
        "--format csv",
        "--no-header",
        "--timestamp",
    )

    def parse_stdout(stdout: str) -> Dict[int, Iterable[Dict]]:
        attachments = dict()

        for line in stdout.splitlines():
            idx, eid, env_name, attached = line.split(",")

            if idx not in attachments:
                attachments[idx] = list()

            if not eid:
                continue

            attachments[idx].append(
                dict(
                    eid=eid,
                    env_name=env_name,
                    attached=attached,
                )
            )

        return attachments

    return {host: parse_stdout(stdout) for host, stdout in zip(hosts, stdouts)}


async def query_envs(hosts: Iterable[str], root: str) -> Dict[str, Dict]:
    """
    Query environments on multiple hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory

    :return: A mapping from host to its active environments
    """
    stdouts = await run_on_hosts(
        hosts,
        root,
        "exec",
        "envs",
        "ps",
        "--format csv",
        "--no-header",
        "--timestamp",
    )

    envs = defaultdict(list)

    for host, stdout in zip(hosts, stdouts):
        for line in stdout.splitlines():
            eid, user, name, creation, pids = line.split(",")

            envs[host].append(
                dict(
                    eid=eid,
                    user=user,
                    name=name,
                    creation=creation,
                    pids=[int(pid) for pid in pids.split(" ")],
                )
            )

    return dict(envs)


async def find_available_host(
    hosts: Iterable[str], root: str, gpus: Optional[int]
) -> str:
    """
    Finds a host with enough available resources.

    Raises 'RuntimeError' if cannot find such host.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory
    :param gpus: Device count specification

    :return: Hostname with enough available resources
    """
    host_to_devices = await query_devices(hosts, root)

    for host, devices in host_to_devices.items():
        available = len(
            [idx for idx, attachments in devices.items() if len(attachments) == 0]
        )

        if gpus is not None:
            if available < gpus:
                continue

        return host

    raise RuntimeError("Cannot find a host with enough available resources")


async def take_snapshots(
    hosts: Iterable[str], root: str
) -> Iterable[genv.usage.Snapshot]:
    """
    Takes usage snapshots on multiple hosts.
    """
    stdouts = await run_on_hosts(
        hosts,
        root,
        "exec",
        "usage",
        "snapshot",
        sudo=True,
    )

    return [json.loads(stdout, cls=genv.usage.JSONDecoder) for stdout in stdouts]


async def execute_reports(
    hosts: Iterable[str],
    root: str,
    reports: Iterable[genv.usage.Report],
    cleanup: bool = True,
) -> None:
    """
    Executes reports on multiple hosts.

    :param cleanup: Don't execute empty reports
    """
    if cleanup:
        filtered = [(host, report) for host, report in zip(hosts, reports) if report]
        hosts = [_[0] for _ in filtered]
        reports = [_[1] for _ in filtered]

    stdouts = await run_on_hosts(
        hosts,
        root,
        "exec",
        "usage",
        "execute",
        stdins=[json.dumps(report, cls=genv.usage.JSONEncoder) for report in reports],
        sudo=True,
    )

    reprint(hosts, stdouts)


def enforce_non_env_processes(
    hosts: Iterable[str],
    snapshots: Iterable[genv.usage.Snapshot],
    surveys: Iterable[genv.usage.Survey],
) -> None:
    for host, snapshot, survey in zip(hosts, snapshots, surveys):
        for process in snapshot.processes:
            if process.eid is not None:
                continue

            print(
                f"Process {process.pid} on host {host} is not running in a GPU environment"
            )

            survey.terminate(process)


def enforce_max_devices_for_user(
    username: str,
    snapshots: Iterable[genv.usage.Snapshot],
    surveys: Iterable[genv.usage.Survey],
    maximum: int,
) -> None:
    attached = sum(len(snapshot.attached()) for snapshot in snapshots)

    if attached <= maximum:
        return

    over = attached - maximum

    hosts = len([snapshot for snapshot in snapshots if len(snapshot.envs) > 0])

    print(
        f"User {username} is using {attached} devices on {hosts} hosts which is {over} more than the maximum allowed"
    )

    detached = 0

    for snapshot, survey in zip(snapshots, surveys):
        for device in snapshot.attached():
            if detached == over:
                break  # already detached enough devices

            survey.detach(
                [env for env in snapshot.envs if env.eid in device.eids], device.index
            )

            detached += 1


def enforce_max_devices_per_user(
    hosts: Iterable[str],
    snapshots: Iterable[genv.usage.Snapshot],
    surveys: Iterable[genv.usage.Survey],
    maximum: int,
) -> None:
    usernames = set(
        env.username for snapshot in snapshots for env in snapshot.envs if env.username
    )

    for username in usernames:
        enforce_max_devices_for_user(
            username,
            snapshots=[snapshot.filter(username) for snapshot in snapshots],
            surveys=surveys,
            maximum=maximum,
        )


async def do_activate(
    hosts: Iterable[str], root: str, gpus: Optional[int], name: Optional[str]
) -> NoReturn:
    """
    Finds a remote host with enough available resources, connects to it using SSH
    and activates an environment inside with the given specification.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory
    :param gpus: Device count specification
    :param name: Environment name specification

    :return: Does not return
    """
    host = await find_available_host(hosts, root, gpus)

    env = {"GENV_PREACTIVATE": 1}

    if gpus:
        env.update({"GENV_PREACTIVATE_GPUS": gpus})

    if name:
        env.update({"GENV_PREACTIVATE_ENVIRONMENT_NAME": name})

    path = shutil.which("ssh")
    args = (
        [path]
        + list(itertools.chain(*(["-o", f"SendEnv={variable}"] for variable in env)))
        + [host]
    )
    env = dict(os.environ, **{k: str(v) for k, v in env.items()})

    os.execve(path, args, env)


async def do_devices(
    hosts: Iterable[str],
    root: str,
    format: str,
    header: bool,
    summary: bool,
) -> None:
    """
    Prints information about devices on multiple hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory
    :param format: Output format
    :param header: Print a header as part of the output
    :param summary: Print a summary as part of the output

    :return: None
    """
    host_to_devices = await query_devices(hosts, root)

    if header:
        if format == "csv":
            print("HOST,TOTAL,AVAILABLE")
        elif format == "tui":
            print("HOST                     TOTAL    AVAILABLE")

    total = 0
    available = 0

    for host, devices in host_to_devices.items():
        host_total = len(devices)
        host_available = len(
            [idx for idx, attachments in devices.items() if len(attachments) == 0]
        )

        total += host_total
        available += host_available

        if format == "csv":
            print(f"{host},{host_total},{host_available}")
        elif format == "tui":
            print(f"{host:<25}{host_total:<9}{host_available}")

    if summary:
        print(
            f"\nTotal {total} devices with {available} available on {len(hosts)} hosts"
        )


async def do_enforce(
    hosts: Iterable[str], root: str, interval: int, max_devices_per_user: Optional[int]
) -> None:
    """
    Enforce GPU usage on multiple hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory

    :return: None
    """
    while True:
        snapshots = await take_snapshots(hosts, root)
        surveys = [genv.usage.Survey() for _ in hosts]

        if args.terminate_non_env_processes:
            enforce_non_env_processes(hosts, snapshots, surveys)

        if max_devices_per_user is not None:
            enforce_max_devices_per_user(
                hosts, snapshots, surveys, maximum=max_devices_per_user
            )

        # TODO(raz): terminate processes that run in environments but on devices that are not attached

        reports = [
            survey.report(snapshot) for snapshot, survey in zip(snapshots, surveys)
        ]

        await execute_reports(hosts, root, reports)

        if interval == 0:
            break

        await asyncio.sleep(interval)


async def do_envs(
    hosts: Iterable[str],
    root: str,
    format: str,
    header: bool,
    summary: bool,
    timestamp: bool,
) -> None:
    """
    Prints information about active environments on multiple hosts.

    :param hosts: Hostnames or IP addresses
    :param root: Genv installation root directory
    :param format: Output format
    :param header: Print a header as part of the output
    :param summary: Print a summary as part of the output

    :return: None
    """
    host_to_envs = await query_envs(hosts, root)

    if header:
        if format == "csv":
            print("HOST,ID,USER,NAME,CREATED")
        elif format == "tui":
            print(
                "HOST                     ID      USER            NAME            CREATED"
            )

    for host, envs in host_to_envs.items():
        for env in envs:
            eid = env["eid"]
            user = env["user"]
            name = env["name"]
            created = (
                env["creation"] if timestamp else genv.utils.time_since(env["creation"])
            )

            if format == "csv":
                print(f"{host},{eid},{user},{name},{created}")
            elif format == "tui":
                print(f"{host:<25}{eid:<8}{user:<16}{name:<16}{created}")

    if summary:
        print(
            f"\nTotal {sum([len(envs) for envs in host_to_envs.values()])} environments on {len(hosts)} hosts"
        )


def parse_args() -> argparse.Namespace:
    """
    Parses the arguments passed to this executable.

    :return: Argument values
    """

    def activate(parser):
        parser.add_argument("--name", help="Environment name")
        parser.add_argument("--gpus", type=int, help="Environment device count")

    def devices(parser):
        parser.add_argument(
            "--no-header",
            dest="header",
            action="store_false",
            help="Do not print column headers",
        )
        parser.add_argument(
            "--no-summary",
            dest="summary",
            action="store_false",
            help="Do not print summary",
        )
        parser.add_argument(
            "--format",
            choices=["csv", "tui"],
            help="Output format; CSV or TUI (Text-based user interface)",
            default="tui",
        )

    def enforce(parser):
        parser.add_argument(
            "--interval",
            type=int,
            default=10,
            help="interval in seconds between enforcement cycles; 0 means run once (default: %(default)s)",
        )

        enforcements = parser.add_argument_group("enforcements")

        def add_enforcement(
            name: str, *, dest: str, help: str, default: bool = True
        ) -> None:
            """
            Adds a mutual exclusive group for an enforcement flag with true and false actions.
            """
            group = enforcements.add_mutually_exclusive_group()

            group.add_argument(
                f"--{name}",
                action="store_true",
                default=default,
                help=help + " (default: %(default)s)",
                dest=dest,
            )

            group.add_argument(
                f"--no-{name}",
                action="store_false",
                dest=dest,
            )

        add_enforcement(
            "non-env-processes",
            dest="terminate_non_env_processes",
            help="terminate processes that are not running in a GPU environment",
            default=False,
        )

        enforcements.add_argument(
            "--max-devices-per-user",
            type=int,
            help="maximum allowed attached devices for each user",
        )

    def envs(parser):
        parser.add_argument(
            "--no-header",
            dest="header",
            action="store_false",
            help="Do not print column headers",
        )
        parser.add_argument(
            "--no-summary",
            dest="summary",
            action="store_false",
            help="Do not print summary",
        )
        parser.add_argument(
            "--timestamp", action="store_true", help="Print a non-prettified timestamp"
        )
        parser.add_argument(
            "--format",
            choices=["csv", "tui"],
            help="Output format; CSV or TUI (Text-based user interface)",
            default="tui",
        )

    parser = argparse.ArgumentParser(description="Genv remote")

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "-H",
        "-host",
        "--host",
        dest="hosts",
        help="Comma-separated hostnames or IP addresses",
    )
    group.add_argument(
        "-hostfile",
        "--hostfile",
        help="A file containing one hostname or IP address per line",
    )

    parser.add_argument(
        "--root",
        default="$HOME/genv",
        help="Genv installation root on remote hosts (default: %(default)s)",
    )

    subparsers = parser.add_subparsers(dest="command")

    for command, help in [
        (activate, "Activate environment in a remote host"),
        (devices, "Show device information from all hosts"),
        (enforce, "Enforce GPU usage on all hosts"),
        (envs, "List all active environments"),
    ]:
        command(subparsers.add_parser(command.__name__, help=help))

    return parser.parse_args()


async def main(args: argparse.Namespace, hosts: Iterable[str]) -> None:
    """
    Parses the arguments and runs the requested command.

    :return: None
    """
    if args.command == "activate":
        await do_activate(hosts, args.root, args.gpus, args.name)
    elif args.command == "devices":
        await do_devices(hosts, args.root, args.format, args.header, args.summary)
    elif args.command == "enforce":
        await do_enforce(hosts, args.root, args.interval, args.max_devices_per_user)
    elif args.command == "envs":
        await do_envs(
            hosts, args.root, args.format, args.header, args.summary, args.timestamp
        )


if __name__ == "__main__":
    args = parse_args()

    if args.hostfile:
        with open(args.hostfile, "r") as f:
            hosts = [line for line in [line.strip() for line in f.readlines()] if line]
    else:
        hosts = args.hosts.split(",")

    try:
        asyncio.run(main(args, hosts))
    except RuntimeError as e:
        print(e, file=sys.stderr)
        exit(1)
    except KeyboardInterrupt:
        if args.command != "enforce":
            raise
